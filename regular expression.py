s = "aabaa"
a = "aab*a*baa*"
#단계 , 마지막에 별이 안붙었다면 무조건 빼고 보기
#생각하는 전략1 *별로 나눠서 매칭 시켜보기
#str의 처음부터 *전까지 매치 매칭된다면 이별 해보고 안될 때 까지 라기보단 다음별의 매칭이 될때까지
#하지만 만약 이전별이 다음별을 포함하고 있다면 이 전략을 어려움
#마지막 전 별은 마지막거에 별이 있다면 매칭될때까지
#없다면 마지막걸 빼고 끝까지 가지나 보면 될듯
#첫 조각 맞추고 마지막 조각을 채우는데 어디까지 채우냐면
#다음 조각 마지막 제외 전체가 들어가는 곳까지 채워지나 본다.
#두번째 조각이 Ax*   A는 문자열 이라고 하면
#ssssssAssssAsssssAssss에서 첫 A를 먼저 검사, 두번째 A를 검사, 마지막으로 3번째 A를 검사
#이는 스택에 넣어서 하면 될듯 만약 첫 A에서 막히면 두번째로 옮기고 여기서 검사할 사항
# 1. 그 전까지 이전의 별로 채워지지 않으면 fail 2. 채워져도 이번에 실패하고 다음 A가 들어갈 곳이 없으면 fail
"""
Ax*  에서 A 머리 x 꼬리
1정규식을 조각으로 나눈다
1번에 대해, 머리가 일치 하는지 확인한다.
2번의 머리와 일치하는 곳의 인덱스를 찾은 뒤, 거기까지 꼬리가 닿는지 확인하고 최종 인덱스를 구한다
여기서 인덱스가 0이라면 False 인덱스에 진입하고 스택에 인덱스 리스트와 몇번째에 들어갔는지 표시를 하던지 아니면 남은 인덱스를 넣던지
이행동을 마지막 전 조각 까지 반복하고 마지막에 별이 없다면 
"""
"""
arr = [2, 7, 10]
for idx, val in enumerate(arr, 5):
    print(idx, val)
"""
a_list = a.split("*")
s_index = 0
list_index = 0
for strs in a_list[:-1]:
    for char in strs[:-1]:
        if s[s_index] == char or char == '.':
            s_index += 1
            pass
        else:
            print("return false")
    #만약 마지막 조각이 아니면(뒤에 별이 있다면)and 문자의 마지막다음 조각의 시작이 나올때까지
    #다음조각의 마지막 전것 까지의것이 포함된 인덱스를 찾고 거기까지 방금 조각으로 채울 수 있는지 확인
    s.find(strs,s_index)